import { Context, Effect, Data, Layer, Config, Redacted } from "effect"
import * as HttpClient from "@effect/platform/HttpClient"
import { makeJsonApi } from "~/lib/http.server"

export class GitHubError extends Data.TaggedError("GitHubError")<{
  readonly message: string
  readonly cause?: unknown
}> {}

export class GitHubClient extends Context.Tag("GitHubClient")<
  GitHubClient,
  {
    readonly createCertPR: (
      inviteId: string,
      email: string,
      username: string,
    ) => Effect.Effect<{ prUrl: string; prNumber: number; certUsername: string }, GitHubError>
    readonly checkPRMerged: (prNumber: number) => Effect.Effect<boolean, GitHubError>
    readonly mergePR: (prNumber: number) => Effect.Effect<void, GitHubError>
    readonly checkWebhookSecret: () => Effect.Effect<boolean, GitHubError>
    readonly closePR: (prNumber: number) => Effect.Effect<void, GitHubError>
    readonly deleteBranch: (inviteId: string) => Effect.Effect<void, GitHubError>
    readonly revertCertFile: (username: string, email: string) => Effect.Effect<{ prNumber: number }, GitHubError>
  }
>() {}

export const GitHubClientLive = Layer.effect(
  GitHubClient,
  Effect.gen(function* () {
    const token = Redacted.value(yield* Config.redacted("GITHUB_TOKEN"))
    const repo = yield* Config.string("GITHUB_REPO").pipe(Config.withDefault("fredericrous/homelab"))
    const http = yield* HttpClient.HttpClient

    const gh = makeJsonApi(
      http,
      `https://api.github.com/repos/${repo}`,
      {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "Content-Type": "application/json",
      },
      (e) => new GitHubError({ message: `GitHub API request failed: ${e}` }),
    )

    const certYaml = (username: string, email: string) =>
      `apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: ${username}
  namespace: vault
  labels:
    homelab.io/pki-domain: client
    homelab.io/generate-p12: "true"
    homelab.io/username: ${username}
  annotations:
    homelab.io/description: "Client certificate for ${email}"
spec:
  secretName: ${username}-client-cert
  issuerRef:
    name: vault-client-pki
    kind: ClusterIssuer
    group: cert-manager.io
  commonName: ${email}
  duration: 8760h
  renewBefore: 720h
  subject:
    organizations:
      - DaddysHome
    organizationalUnits:
      - Users
  usages:
    - client auth
    - digital signature
    - key encipherment
  privateKey:
    algorithm: RSA
    size: 2048
`

    return {
      createCertPR: (inviteId: string, email: string, username: string) =>
        Effect.gen(function* () {
          const branch = `cert/invite-${inviteId}`
          const filePath = `kubernetes/nas/platform-foundation/vault/client-certs/certificates/${username}.yaml`

          // Check if branch already exists (idempotency)
          const branchExists = yield* gh.get(`/git/refs/heads/${branch}`).pipe(
            Effect.map(() => true),
            Effect.catchAll(() => Effect.succeed(false)),
          ) // 404 = branch doesn't exist, expected

          if (branchExists) {
            // Branch exists, check for existing PR
            const prs = yield* gh.get(`/pulls?head=fredericrous:${branch}&state=open`).pipe(
              Effect.map((r) => r as unknown as Array<{ html_url: string; number: number }>),
              Effect.tapError((e) => Effect.logDebug("Failed to list PRs for branch", { error: String(e), branch })),
              Effect.catchAll(() => Effect.succeed([] as Array<{ html_url: string; number: number }>)),
            )

            if (prs.length > 0) {
              const certUsername = username.toLowerCase().replace(/[^a-z0-9_-]/g, "")
              return { prUrl: prs[0].html_url, prNumber: prs[0].number, certUsername }
            }
          }

          // Get main branch SHA
          const mainRef = yield* gh.get(`/git/refs/heads/main`)
          const mainSha = (mainRef as { object: { sha: string } }).object.sha

          // Create branch
          if (!branchExists) {
            yield* gh.post(`/git/refs`, {
              ref: `refs/heads/${branch}`,
              sha: mainSha,
            })
          }

          // Create file
          const normalizedUsername = username.toLowerCase().replace(/[^a-z0-9_-]/g, "")
          const content = certYaml(normalizedUsername, email)

          yield* gh.put(`/contents/${filePath}`, {
            message: `feat: add client certificate for ${email}`,
            content: Buffer.from(content).toString("base64"),
            branch,
          })

          // Create PR
          const pr = yield* gh.post(`/pulls`, {
            title: `feat: add client certificate for ${email}`,
            body: "Auto-generated by Duro invite system.\n\nThis PR adds a cert-manager Certificate for automatic renewal of the client certificate.",
            head: branch,
            base: "main",
          })

          return {
            prUrl: (pr as { html_url: string }).html_url,
            prNumber: (pr as { number: number }).number,
            certUsername: normalizedUsername,
          }
        }),

      checkPRMerged: (prNumber: number) =>
        gh.get(`/pulls/${prNumber}`).pipe(Effect.map((pr) => !!(pr as { merged: boolean }).merged)),

      mergePR: (prNumber: number) => gh.put(`/pulls/${prNumber}/merge`, { merge_method: "squash" }).pipe(Effect.asVoid),

      checkWebhookSecret: () =>
        gh.get(`/actions/secrets/DURO_WEBHOOK_SECRET`).pipe(
          Effect.as(true),
          Effect.catchAll(() => Effect.succeed(false)),
        ),

      closePR: (prNumber: number) =>
        gh.patch(`/pulls/${prNumber}`, { state: "closed" }).pipe(
          Effect.asVoid,
          Effect.tapError((e) => Effect.logWarning("Failed to close PR", { prNumber, error: String(e) })),
          Effect.catchAll(() => Effect.void),
        ),

      deleteBranch: (inviteId: string) =>
        gh.del(`/git/refs/heads/cert/invite-${inviteId}`).pipe(
          Effect.asVoid,
          Effect.tapError((e) => Effect.logWarning("Failed to delete branch", { inviteId, error: String(e) })),
          Effect.catchAll(() => Effect.void),
        ),

      revertCertFile: (username: string, email: string) =>
        Effect.gen(function* () {
          const filePath = `kubernetes/nas/platform-foundation/vault/client-certs/certificates/${username}.yaml`
          const branch = `cert/revoke-${username}`

          // Get main branch SHA
          const mainRef = yield* gh.get(`/git/refs/heads/main`)
          const mainSha = (mainRef as { object: { sha: string } }).object.sha

          // Create branch
          yield* gh.post(`/git/refs`, {
            ref: `refs/heads/${branch}`,
            sha: mainSha,
          })

          // Create new tree without the file using Git Data API (sha: null = delete)
          const newTree = yield* gh.post(`/git/trees`, {
            base_tree: mainSha,
            tree: [
              {
                path: filePath,
                mode: "100644",
                type: "blob",
                sha: null,
              },
            ],
          })
          const newTreeSha = (newTree as { sha: string }).sha

          // Create commit
          const commit = yield* gh.post(`/git/commits`, {
            message: `chore: revoke client certificate for ${email}`,
            tree: newTreeSha,
            parents: [mainSha],
          })
          const commitSha = (commit as { sha: string }).sha

          // Update branch ref
          yield* gh.patch(`/git/refs/heads/${branch}`, {
            sha: commitSha,
            force: true,
          })

          // Create PR
          const pr = yield* gh.post(`/pulls`, {
            title: `chore: revoke client certificate for ${email}`,
            body: "Auto-generated by Duro. This PR removes the cert-manager Certificate for a revoked user.",
            head: branch,
            base: "main",
          })
          const prNumber = (pr as { number: number }).number

          return { prNumber }
        }),
    }
  }),
)
