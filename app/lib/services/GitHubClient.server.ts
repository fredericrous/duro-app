import { Context, Effect, Data, Layer } from "effect"

export class GitHubError extends Data.TaggedError("GitHubError")<{
  readonly message: string
  readonly cause?: unknown
}> {}

export class GitHubClient extends Context.Tag("GitHubClient")<
  GitHubClient,
  {
    readonly createCertPR: (
      inviteId: string,
      email: string,
      username: string,
    ) => Effect.Effect<{ prUrl: string; prNumber: number }, GitHubError>
    readonly checkPRMerged: (
      prNumber: number,
    ) => Effect.Effect<boolean, GitHubError>
  }
>() {}

export const GitHubClientLive = Layer.effect(
  GitHubClient,
  Effect.gen(function* () {
    const token = process.env.GITHUB_TOKEN ?? ""
    const repo = process.env.GITHUB_REPO ?? "fredericrous/homelab"

    const ghFetch = (path: string, options?: RequestInit) =>
      Effect.tryPromise({
        try: () =>
          fetch(`https://api.github.com/repos/${repo}${path}`, {
            ...options,
            headers: {
              Authorization: `Bearer ${token}`,
              Accept: "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "Content-Type": "application/json",
              ...options?.headers,
            },
          }).then(async (r) => {
            const body = await r.json().catch(() => ({}))
            if (!r.ok) {
              throw new Error(
                `GitHub API ${r.status}: ${JSON.stringify(body)}`,
              )
            }
            return body as Record<string, unknown>
          }),
        catch: (e) =>
          new GitHubError({ message: "GitHub API request failed", cause: e }),
      })

    const certYaml = (username: string, email: string) =>
      `apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: client-cert-${username}
  namespace: vault
spec:
  secretName: client-cert-${username}
  issuerRef:
    name: vault-pki-client
    kind: ClusterIssuer
  commonName: ${email}
  duration: 2160h
  renewBefore: 720h
  privateKey:
    algorithm: RSA
    size: 2048
  usages:
    - client auth
`

    return {
      createCertPR: (inviteId: string, email: string, username: string) =>
        Effect.gen(function* () {
          const branch = `cert/invite-${inviteId}`
          const filePath = `kubernetes/nas/platform-foundation/vault/client-certs/certificates/${username}.yaml`

          // Check if branch already exists (idempotency)
          const branchExists = yield* ghFetch(
            `/git/refs/heads/${branch}`,
          ).pipe(
            Effect.map(() => true),
            Effect.catchAll(() => Effect.succeed(false)),
          )

          if (branchExists) {
            // Branch exists, check for existing PR
            const prs = yield* ghFetch(
              `/pulls?head=fredericrous:${branch}&state=open`,
            ).pipe(
              Effect.map((r) => r as unknown as Array<{ html_url: string; number: number }>),
              Effect.catchAll(() => Effect.succeed([] as Array<{ html_url: string; number: number }>)),
            )

            if (prs.length > 0) {
              return { prUrl: prs[0].html_url, prNumber: prs[0].number }
            }
          }

          // Get main branch SHA
          const mainRef = yield* ghFetch(`/git/refs/heads/main`)
          const mainSha = (
            mainRef as { object: { sha: string } }
          ).object.sha

          // Create branch
          if (!branchExists) {
            yield* ghFetch(`/git/refs`, {
              method: "POST",
              body: JSON.stringify({
                ref: `refs/heads/${branch}`,
                sha: mainSha,
              }),
            })
          }

          // Create file
          const normalizedUsername = username
            .toLowerCase()
            .replace(/[^a-z0-9_-]/g, "")
          const content = certYaml(normalizedUsername, email)

          yield* ghFetch(`/contents/${filePath}`, {
            method: "PUT",
            body: JSON.stringify({
              message: `feat: add client certificate for ${email}`,
              content: Buffer.from(content).toString("base64"),
              branch,
            }),
          })

          // Create PR
          const pr = yield* ghFetch(`/pulls`, {
            method: "POST",
            body: JSON.stringify({
              title: `feat: add client certificate for ${email}`,
              body: "Auto-generated by Duro invite system.\n\nThis PR adds a cert-manager Certificate for automatic renewal of the client certificate.",
              head: branch,
              base: "main",
            }),
          })

          return {
            prUrl: (pr as { html_url: string }).html_url,
            prNumber: (pr as { number: number }).number,
          }
        }),

      checkPRMerged: (prNumber: number) =>
        ghFetch(`/pulls/${prNumber}`).pipe(
          Effect.map((pr) => !!(pr as { merged: boolean }).merged),
        ),
    }
  }),
)
